#pragma config(Sensor, S2,     snrRHS,         sensorSONAR)
#pragma config(Sensor, S3,     lghtSNS,        sensorLightActive)
#pragma config(Sensor, S4,     snrFRNT,        sensorSONAR)
#pragma config(Motor,  motorB,          mtrRHS,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mtrLHS,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//CODE FOR ENGG282 - V1 - 18-07-17
void moveForward() {
	motor[mtrRHS] = 25;
	motor[mtrLHS] = 25;
	wait1Msec(1000);
}

void turnRight() {
	motor[mtrRHS] = -25;
	motor[mtrLHS] = 25;
	wait1Msec(720);
	motor[mtrRHS] = 0;
	motor[mtrLHS] = 0;
}

void wallGap() {
	motor[mtrRHS] = -25;
	motor[mtrLHS] = 25;
	wait1Msec(720);
	motor[mtrRHS] = 25;
	motor[mtrLHS] = 25;
	wait10Msec(200);
}


void tLight()
{
	// Variables for light value and whether the light is found
	int lightSensor = SensorValue(lghtSNS);
	bool lightFound = false;

	while(lightFound == false)
	{
		// Look for the light, if it is found, indicate it programatically
		if (lightSensor > 32){
			lightFound = true;
		}
	}
	//9 pivot values in a 90 degree range?
	//turn to the left looking for highest intensity
	//turn to the right looking for highest intensity
	//move towards the highest intensity
	while (lightFound) {
		//set zero
		//go forward for 200ms
		//check for light again
	}
}
void tSonarFront()
{
		// Variables for sonar reading and distance from front
		int sonarValue = SensorValue(snrFRNT);
		int distFromFront = 40;

		// If there is a range error - i.e sonar not receiving sonar signal back
		if (sonarValue == 255)
  	{
 		 	moveForward();
 		}
		// The front wall is close, turn away from it
		else if (sonarValue < distFromFront)
		{
			turnRight();
			wait1Msec(1000);
		}
		// Continue forwards
		else
		{
			moveForward();
		}
}
void tSonarRight()
{
	int sonarValue = SensorValue(snrRHS);
	int distFromRight = 25;
	//If there is a range error - i.e sonar not receiving sonar signal back
	if (sonarValue == 255){
  	moveForward();
  }
  // Turn needs to be made
  else if (sonarValue > distFromRight)
  {
  	wallGap();
  	//moveForward();
  	motor[mtrRHS] = 0;
		motor[mtrLHS] = 0;
  	wait1Msec(1000);
  }
  //If the sonar is returning a range within 16-24, then it is relatively close to the wall
  /*else if(sonarValue >= 16 && sonarValue <=24) {
  	// Too far away from the wall, set the RHS wheel to go slower so that it turns towards the wall
  	if(sonarValue > 21){
  	motor[mtrRHS] = 20;
  	motor[mtrLHS] = 25;
  	wait1Msec(300);
  	}
  	// Too close to the wall, set the LHS wheel to go slower so that it turns away from the wall
  	else if (sonarValue < 19){
  		motor[mtrRHS] = 25;
  		motor[mtrLHS] = 20;
  		wait1MSec(300);
  	}*/
  	// Else, all is well, continue moving forawrd on the path
  	else
  	{
  		moveForward();
  		wait1Msec(300);
  	}
}
task main()
{
	while (true)
	{
		// The robot should only move not forward because of 1 of 3 reasons
		// 1. It senses a wall in front, so will turn right so as to not run into it
		// 2. It does not sense a wall on the right, so turns right to find a wall
		// 3. It sees the light and moves towards it

		tSonarRight();
		tSonarFront();
	}

}
// Concept 1: This
// COncept 2: Use curved edges to auto correct the robot
// Concept 3: bumper instead of sonar
