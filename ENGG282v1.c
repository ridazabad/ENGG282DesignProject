#pragma config(Sensor, S2,     snrRHS,         sensorSONAR)
#pragma config(Sensor, S3,     lghtSNS,        sensorLightActive)
#pragma config(Sensor, S4,     snrFRNT,        sensorSONAR)
#pragma config(Motor,  motorB,          mtrRHS,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mtrLHS,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//CODE FOR ENGG282 - V1 - 18-07-17
///////////////////////////////////////////////////////////////////////////////////////////
int steps[150];
//Condition 1
void moveForward() {
    motor[mtrRHS] = 22;
    motor[mtrLHS] = 22;
    wait1Msec(2830);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(500);
}
//Condition 2
void turnLeft() {
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(200);
    motor[mtrRHS] = 15;
    motor[mtrLHS] = -15;
    wait1Msec(1430);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(500);
}
//Condition 3
void turnRight() {
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(50);
    motor[mtrRHS] = -15;
    motor[mtrLHS] = 15;
    wait1Msec(1430);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(500);
    motor[mtrRHS] = 22;
    motor[mtrLHS] = 22;
    wait1Msec(2830);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(500);

}
void lightFnc(){
		motor[mtrRHS] = 20;
    motor[mtrLHS] = 20;
    wait1Msec(3000);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(100);
    motor[mtrRHS] = -15;
    motor[mtrLHS] = -15;
    wait1Msec(1500);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(100);
    motor[mtrRHS] = 20;
    motor[mtrLHS] = 20;
    wait1Msec(3000);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(100);
    motor[mtrRHS] = -15;
    motor[mtrLHS] = -15;
    wait1Msec(1500);
    motor[mtrRHS] = 0;
    motor[mtrLHS] = 0;
    wait1Msec(100);
}
//Method to control the robot
void action(int i, int pos) {
    steps[pos] = i;
    if (i == 1){
        moveForward();
    }
    else if (i == 2) {
        turnLeft();
    }
    else if (i == 3) {
        turnRight();
    }
    else if(i == 4){
    		lightFnc();
  	}
    else {
    	return;
    }
}
///////////////////////////////////////////////////////////////////////////////////////////
//tLight
int tLight(){
				int lightSensor = SensorValue(lghtSNS);
				int distance = 34;
				
				//CHeck if it sees a light
				if(lightSensor <= distance){
						return 4;
				}
				else{
						return 1;
				}
}
int tSonarFront()
{
        // Variables for sonar reading and distance from front
        int sonarValue = SensorValue(snrFRNT);
        int distFromFront = 25;

        // If there is a range error - i.e sonar not receiving sonar signal back
        if (sonarValue == 255)
    {
        //moveForward
            return 1;
        }
        // The front wall is close, turn to the left of it, move back first
        else if (sonarValue < distFromFront)
        {
            //turnLeft();
        return 2;
        }
        // Move forward as normal
        else
        {
            //moveForward();
            return 1;
        }
}
int tSonarRight()
{
    int sonarValue = SensorValue(snrRHS);
    int distFromRight = 28;
    //If there is a range error - i.e sonar not receiving sonar signal back
    if (sonarValue == 255){
    return 1;
  	}
  	// Turn needs to be made
  	else if (sonarValue > distFromRight)
  	{
    //wallGap();
    return 3;
  	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
    int pos = 0;
    while (true)
    {
    		int z = tLight();
    		wait1Msec(200);
        int x = tSonarFront();
        wait1Msec(200);
        int y = tSonarRight();
        //int z = tLight();
        //Modify this for three conditions
        if(z > x)
        {
            action(z, pos);
        }
        else if(x >= y)
        {
            action(x, pos);
        }
        else if(y > x)
      	{
      			action(y, pos);
    		}
        pos = pos + 1;
    }

}
// Concept 1: This
// Concept 2: Use curved edges to auto correct the robot
// Concept 3: bumper instead of sonar

/*
Different Conditions:
1. Wall is on the RHS - moveForward
2. Wall is on the RHS but there is a wall in front - turnLeft OR turnRight x3
3. No wall on RHS but turn right and there is a wall on the RHS - turnRight
4. No wall on RHS but turn right and still no wall on the RHS - wallGap
5. Reached the light - lightFound

The greater the number on these conditions = the step that takes precedence

Have the program work in that it stores all the steps by passing out int values from the methods
Then have an array of all the steps it take in the main program so that it can follow all these steps backwards again

*/
